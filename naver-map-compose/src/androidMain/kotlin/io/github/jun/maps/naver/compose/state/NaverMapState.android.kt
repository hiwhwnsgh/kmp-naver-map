package io.github.jun.maps.naver.compose.state

import android.content.Context
import android.graphics.PointF
import android.graphics.drawable.GradientDrawable
import android.util.TypedValue
import android.view.View
import android.widget.TextView
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import com.naver.maps.map.CameraAnimation
import com.naver.maps.map.CameraUpdate
import com.naver.maps.map.LocationSource
import com.naver.maps.map.NaverMap
import io.github.jun.maps.naver.compose.internal.*
import io.github.jun.maps.naver.compose.model.CameraPosition
import io.github.jun.maps.naver.compose.model.LatLng
import io.github.jun.maps.naver.compose.model.LatLngBounds
import io.github.jun.maps.naver.compose.model.LocationTrackingMode
import io.github.jun.maps.naver.compose.model.MapType
import io.github.jun.maps.naver.compose.model.Symbol
import io.github.jun.maps.naver.compose.options.ArrowheadPathOptions
import io.github.jun.maps.naver.compose.options.CircleOptions
import io.github.jun.maps.naver.compose.options.InfoWindowOptions
import io.github.jun.maps.naver.compose.options.LocationOverlayOptions
import io.github.jun.maps.naver.compose.options.MapUiSettings
import io.github.jun.maps.naver.compose.options.MarkerOptions
import io.github.jun.maps.naver.compose.options.PathOptions
import io.github.jun.maps.naver.compose.options.PolygonOptions
import io.github.jun.maps.naver.compose.options.PolylineOptions
import io.github.jun.maps.naver.compose.overlay.ArrowheadPathOverlay
import io.github.jun.maps.naver.compose.overlay.CircleOverlay
import io.github.jun.maps.naver.compose.overlay.InfoWindow
import io.github.jun.maps.naver.compose.overlay.Marker
import io.github.jun.maps.naver.compose.overlay.OverlayImage
import io.github.jun.maps.naver.compose.overlay.PathOverlay
import io.github.jun.maps.naver.compose.overlay.PolygonOverlay
import io.github.jun.maps.naver.compose.overlay.PolylineOverlay

actual class NaverMapState actual constructor(
    private val initialPosition: CameraPosition
) {
    private val _isMapReady = mutableStateOf(false)
    actual val isMapReady: Boolean get() = _isMapReady.value

    internal var _context: Context? = null

    // 카메라 위치를 State로 관리하여 실시간 동기화
    private var _cameraPosition by mutableStateOf(initialPosition)
    actual var cameraPosition: CameraPosition
        get() = _cameraPosition
        set(value) {
            _cameraPosition = value
            naverMap?.moveCamera(CameraUpdate.toCameraPosition(value.toNaver()))
        }

    // 현재 보이는 영역을 State로 관리
    private val _contentRegion = mutableStateOf<LatLngBounds?>(null)
    actual val contentRegion: LatLngBounds? get() = _contentRegion.value

    internal var naverMap: NaverMap? = null
        set(value) {
            field = value
            _isMapReady.value = value != null
            if (value != null) {
                value.locationSource = _locationSource
                applyUiSettings()
                applyLocationTrackingMode()
                applyLocationOverlayOptions()
                applyCameraConstraints()
                setupListeners(value)
                
                // 초기 상태 동기화
                _cameraPosition = value.cameraPosition.toCommon()
                _contentRegion.value = value.contentRegion.toCommonBounds()
            }
        }

    private var _locationSource: LocationSource? = null
    var locationSource: LocationSource?
        get() = _locationSource
        set(value) {
            _locationSource = value
            naverMap?.locationSource = value
        }

    private var _lastLocation = mutableStateOf<LatLng?>(null)
    actual val lastLocation: LatLng? get() = _lastLocation.value

    actual var onLocationChange: ((LatLng) -> Unit)? = null

    private val _markers = mutableListOf<Marker>()
    private val _polylines = mutableListOf<PolylineOverlay>()
    private val _polygons = mutableListOf<PolygonOverlay>()
    private val _circles = mutableListOf<CircleOverlay>()
    private val _paths = mutableListOf<PathOverlay>()
    private val _arrowheadPaths = mutableListOf<ArrowheadPathOverlay>()
    private val _infoWindows = mutableListOf<InfoWindow>()

    private var _uiSettings = MapUiSettings()
    actual var uiSettings: MapUiSettings
        get() = _uiSettings
        set(value) {
            _uiSettings = value
            applyUiSettings()
        }

    private fun applyUiSettings() {
        naverMap?.let { map ->
            val settings = map.uiSettings
            settings.isScrollGesturesEnabled = _uiSettings.isScrollGesturesEnabled
            settings.isZoomGesturesEnabled = _uiSettings.isZoomGesturesEnabled
            settings.isTiltGesturesEnabled = _uiSettings.isTiltGesturesEnabled
            settings.isRotateGesturesEnabled = _uiSettings.isRotateGesturesEnabled
            settings.isStopGesturesEnabled = _uiSettings.isStopGesturesEnabled
            settings.isCompassEnabled = _uiSettings.isCompassEnabled
            settings.isScaleBarEnabled = _uiSettings.isScaleBarEnabled
            settings.isZoomControlEnabled = _uiSettings.isZoomControlEnabled
            settings.isIndoorLevelPickerEnabled = _uiSettings.isIndoorLevelPickerEnabled
            settings.isLocationButtonEnabled = _uiSettings.isLocationButtonEnabled
            settings.isLogoClickEnabled = _uiSettings.isLogoClickEnabled

            map.setLayerGroupEnabled(NaverMap.LAYER_GROUP_BUILDING, _uiSettings.isBuildingLayerGroupEnabled)
            map.setLayerGroupEnabled(NaverMap.LAYER_GROUP_TRANSIT, _uiSettings.isTransitLayerGroupEnabled)
            map.setLayerGroupEnabled(NaverMap.LAYER_GROUP_BICYCLE, _uiSettings.isBicycleLayerGroupEnabled)
            map.setLayerGroupEnabled(NaverMap.LAYER_GROUP_TRAFFIC, _uiSettings.isTrafficLayerGroupEnabled)
            map.setLayerGroupEnabled(NaverMap.LAYER_GROUP_MOUNTAIN, _uiSettings.isMountainLayerGroupEnabled)
            map.setLayerGroupEnabled(NaverMap.LAYER_GROUP_CADASTRAL, _uiSettings.isCadastralLayerGroupEnabled)
        }
    }

    private var _locationTrackingMode = mutableStateOf(LocationTrackingMode.None)
    actual var locationTrackingMode: LocationTrackingMode
        get() = _locationTrackingMode.value
        set(value) {
            if (_locationTrackingMode.value != value) {
                _locationTrackingMode.value = value
                applyLocationTrackingMode()
            }
        }

    private fun applyLocationTrackingMode() {
        naverMap?.locationTrackingMode = _locationTrackingMode.value.toNaver()
    }

    private var _locationOverlayOptions = LocationOverlayOptions()
    actual var locationOverlayOptions: LocationOverlayOptions
        get() = _locationOverlayOptions
        set(value) {
            _locationOverlayOptions = value
            applyLocationOverlayOptions()
        }

    private fun applyLocationOverlayOptions() {
        naverMap?.locationOverlay?.let { overlay ->
            overlay.isVisible = _locationOverlayOptions.isVisible
            (_locationOverlayOptions.icon as? OverlayImage)?.let { overlay.icon = it.nativeImage }
            
            overlay.iconWidth = if (_locationOverlayOptions.width == Marker.MarkerSize.AUTO)
                com.naver.maps.map.overlay.Marker.SIZE_AUTO
            else _locationOverlayOptions.width.dpToPx().toInt()
            overlay.iconHeight = if (_locationOverlayOptions.height == Marker.MarkerSize.AUTO)
                com.naver.maps.map.overlay.Marker.SIZE_AUTO
            else _locationOverlayOptions.height.dpToPx().toInt()
            overlay.anchor = PointF(_locationOverlayOptions.anchor.first, _locationOverlayOptions.anchor.second)
            overlay.bearing = _locationOverlayOptions.bearing
            overlay.globalZIndex = _locationOverlayOptions.globalZIndex
            
            overlay.circleRadius = _locationOverlayOptions.circleRadius.toInt()
            overlay.circleColor = _locationOverlayOptions.circleColor
            overlay.circleOutlineWidth = _locationOverlayOptions.circleOutlineWidth.dpToPx().toInt()
            overlay.circleOutlineColor = _locationOverlayOptions.circleOutlineColor
            
            if (_locationOverlayOptions.isSubIconVisible) {
                (_locationOverlayOptions.subIcon as? OverlayImage)?.let { overlay.subIcon = it.nativeImage }
            } else {
                overlay.subIcon = null
            }
            
            overlay.subIconWidth = if (_locationOverlayOptions.subIconWidth == Marker.MarkerSize.AUTO)
                com.naver.maps.map.overlay.Marker.SIZE_AUTO
            else _locationOverlayOptions.subIconWidth.dpToPx().toInt()
            overlay.subIconHeight = if (_locationOverlayOptions.subIconHeight == Marker.MarkerSize.AUTO)
                com.naver.maps.map.overlay.Marker.SIZE_AUTO
            else _locationOverlayOptions.subIconHeight.dpToPx().toInt()
            overlay.subAnchor = PointF(_locationOverlayOptions.subIconAnchor.first, _locationOverlayOptions.subIconAnchor.second)
        }
    }

    private var _minZoom: Double = 0.0
    actual var minZoom: Double
        get() = _minZoom
        set(value) {
            _minZoom = value
            naverMap?.minZoom = value
        }

    private var _maxZoom: Double = 21.0
    actual var maxZoom: Double
        get() = _maxZoom
        set(value) {
            _maxZoom = value
            naverMap?.maxZoom = value
        }

    private var _extent: LatLngBounds? = null
    actual var extent: LatLngBounds?
        get() = _extent
        set(value) {
            _extent = value
            naverMap?.extent = value?.toNaver()
        }

    private fun applyCameraConstraints() {
        naverMap?.let { map ->
            map.minZoom = _minZoom
            map.maxZoom = _maxZoom
            map.extent = _extent?.toNaver()
        }
    }

    actual var onCameraChange: ((reason: Int, animated: Boolean) -> Unit)? = null
    actual var onCameraIdle: (() -> Unit)? = null
    actual var onCameraChangeStarted: ((reason: Int) -> Unit)? = null

    actual var onMapClick: ((latLng: LatLng) -> Unit)? = null
    actual var onSymbolClick: ((symbol: Symbol) -> Boolean)? = null

    private fun setupListeners(map: NaverMap) {
        map.addOnCameraChangeListener { reason, animated ->
            // 카메라 상태 동기화
            _cameraPosition = map.cameraPosition.toCommon()
            _contentRegion.value = map.contentRegion.toCommonBounds()
            onCameraChange?.invoke(reason, animated)
        }
        map.addOnCameraIdleListener {
            onCameraIdle?.invoke()
        }
        
        map.setOnMapClickListener { _, latLng ->
            onMapClick?.invoke(latLng.toCommon())
        }
        
        map.setOnSymbolClickListener { symbol ->
            onSymbolClick?.invoke(Symbol(symbol.caption, symbol.position.toCommon())) ?: false
        }

        map.addOnLocationChangeListener { location ->
            val latLng = LatLng(location.latitude, location.longitude)
            _lastLocation.value = latLng
            onLocationChange?.invoke(latLng)
        }

        map.addOnOptionChangeListener {
            val mode = map.locationTrackingMode
            _locationTrackingMode.value = mode.toCommon()
        }
    }

    actual fun addMarker(options: MarkerOptions): Marker {
        val nativeMarker = com.naver.maps.map.overlay.Marker().apply {
            position = options.position.toNaver()
            (options.icon as? OverlayImage)?.let { icon = it.nativeImage }
            captionText = options.caption
            subCaptionText = options.subCaption
            alpha = options.alpha
            isVisible = options.isVisible
            isFlat = options.isFlat
            isForceShowCaption = options.isForceShowCaption
            isForceShowIcon = options.isForceShowIcon
            zIndex = options.zIndex
            globalZIndex = options.globalZIndex
            width = if (options.width == Marker.MarkerSize.AUTO) com.naver.maps.map.overlay.Marker.SIZE_AUTO else options.width.dpToPx().toInt()
            height = if (options.height == Marker.MarkerSize.AUTO) com.naver.maps.map.overlay.Marker.SIZE_AUTO else options.height.dpToPx().toInt()
            angle = options.angle
            anchor = PointF(options.anchor.first, options.anchor.second)
            minZoom = options.minZoom
            maxZoom = options.maxZoom
            isMinZoomInclusive = options.isMinZoomInclusive
            isMaxZoomInclusive = options.isMaxZoomInclusive
            captionColor = options.captionColor
            captionHaloColor = options.captionHaloColor
            captionTextSize = options.captionTextSize
            captionMinZoom = options.captionMinZoom
            captionMaxZoom = options.captionMaxZoom
            captionRequestedWidth = options.captionRequestedWidth.dpToPx().toInt()
            captionOffset = options.captionOffset.dpToPx().toInt()
            isCaptionPerspectiveEnabled = options.captionPerspectiveEnabled
            subCaptionColor = options.subCaptionColor
            subCaptionHaloColor = options.subCaptionHaloColor
            subCaptionTextSize = options.subCaptionTextSize
            subCaptionMinZoom = options.subCaptionMinZoom
            subCaptionMaxZoom = options.subCaptionMaxZoom
            subCaptionRequestedWidth = options.subCaptionRequestedWidth.toInt()
            isHideCollidedMarkers = options.isHideCollidedMarkers
            isHideCollidedSymbols = options.isHideCollidedSymbols
            isHideCollidedCaptions = options.isHideCollidedCaptions
            isIconPerspectiveEnabled = options.isIconPerspectiveEnabled
            if (options.iconTintColor != 0) iconTintColor = options.iconTintColor
            tag = options.tag
            map = naverMap
        }
        return Marker(nativeMarker).also { _markers.add(it) }
    }

    actual fun removeMarker(marker: Marker) {
        marker.nativeMarker.map = null
        _markers.remove(marker)
    }

    actual fun clearMarkers() {
        _markers.forEach { it.nativeMarker.map = null }
        _markers.clear()
    }

    actual fun addPolyline(options: PolylineOptions): PolylineOverlay {
        val nativePolyline = com.naver.maps.map.overlay.PolylineOverlay().apply {
            coords = options.coords.map { it.toNaver() }
            color = options.color
            width = options.width.dpToPx().toInt()
            capType = options.capType.toNaver()
            joinType = options.joinType.toNaver()
            zIndex = options.zIndex
            isVisible = options.isVisible
            tag = options.tag
            map = naverMap
        }
        return PolylineOverlay(nativePolyline).also { _polylines.add(it) }
    }

    actual fun removePolyline(overlay: PolylineOverlay) {
        overlay.nativePolyline.map = null
        _polylines.remove(overlay)
    }

    actual fun clearPolylines() {
        _polylines.forEach { it.nativePolyline.map = null }
        _polylines.clear()
    }

    actual fun addPolygon(options: PolygonOptions): PolygonOverlay {
        val nativePolygon = com.naver.maps.map.overlay.PolygonOverlay().apply {
            coords = options.coords.map { it.toNaver() }
            holes = options.holes.map { hole -> hole.map { it.toNaver() } }
            color = options.fillColor
            outlineColor = options.outlineColor
            outlineWidth = options.outlineWidth.dpToPx().toInt()
            zIndex = options.zIndex
            isVisible = options.isVisible
            tag = options.tag
            map = naverMap
        }
        return PolygonOverlay(nativePolygon).also { _polygons.add(it) }
    }

    actual fun removePolygon(overlay: PolygonOverlay) {
        overlay.nativePolygon.map = null
        _polygons.remove(overlay)
    }

    actual fun clearPolygons() {
        _polygons.forEach { it.nativePolygon.map = null }
        _polygons.clear()
    }

    actual fun addCircle(options: CircleOptions): CircleOverlay {
        val nativeCircle = com.naver.maps.map.overlay.CircleOverlay().apply {
            center = options.center.toNaver()
            radius = options.radius
            color = options.fillColor
            outlineColor = options.outlineColor
            outlineWidth = options.outlineWidth.dpToPx().toInt()
            zIndex = options.zIndex
            isVisible = options.isVisible
            tag = options.tag
            map = naverMap
        }
        return CircleOverlay(nativeCircle).also { _circles.add(it) }
    }

    actual fun removeCircle(overlay: CircleOverlay) {
        overlay.nativeCircle.map = null
        _circles.remove(overlay)
    }

    actual fun clearCircles() {
        _circles.forEach { it.nativeCircle.map = null }
        _circles.clear()
    }

    actual fun addPath(options: PathOptions): PathOverlay {
        val nativePath = com.naver.maps.map.overlay.PathOverlay().apply {
            coords = options.coords.map { it.toNaver() }
            width = options.width.dpToPx().toInt()
            outlineWidth = options.outlineWidth.dpToPx().toInt()
            color = options.color
            outlineColor = options.outlineColor
            passedColor = options.passedColor
            passedOutlineColor = options.passedOutlineColor
            progress = options.progress
            patternInterval = options.patternInterval.dpToPx().toInt()
            isHideCollidedSymbols = options.isHideCollidedSymbols
            isHideCollidedMarkers = options.isHideCollidedMarkers
            isHideCollidedCaptions = options.isHideCollidedCaptions
            zIndex = options.zIndex
            isVisible = options.isVisible
            tag = options.tag
            map = naverMap
        }
        return PathOverlay(nativePath).also { _paths.add(it) }
    }

    actual fun removePath(overlay: PathOverlay) {
        overlay.nativePathOverlay.map = null
        _paths.remove(overlay)
    }

    actual fun clearPaths() {
        _paths.forEach { it.nativePathOverlay.map = null }
        _paths.clear()
    }

    actual fun addArrowheadPath(options: ArrowheadPathOptions): ArrowheadPathOverlay {
        val nativeArrowheadPath = com.naver.maps.map.overlay.ArrowheadPathOverlay().apply {
            coords = options.coords.map { it.toNaver() }
            width = options.width.dpToPx().toInt()
            outlineWidth = options.outlineWidth.dpToPx().toInt()
            color = options.color
            outlineColor = options.outlineColor
            elevation = options.elevation.dpToPx().toInt()
            headSizeRatio = options.headSizeRatio
            zIndex = options.zIndex
            isVisible = options.isVisible
            tag = options.tag
            map = naverMap
        }
        return ArrowheadPathOverlay(nativeArrowheadPath).also { _arrowheadPaths.add(it) }
    }

    actual fun removeArrowheadPath(overlay: ArrowheadPathOverlay) {
        overlay.nativeArrowheadPathOverlay.map = null
        _arrowheadPaths.remove(overlay)
    }

    actual fun clearArrowheadPaths() {
        _arrowheadPaths.forEach { it.nativeArrowheadPathOverlay.map = null }
        _arrowheadPaths.clear()
    }

    actual fun addInfoWindow(options: InfoWindowOptions, marker: Marker?): InfoWindow {
        val adapterContext = _context ?: throw IllegalStateException("Context is not available. Ensure the map is ready.")
        val nativeInfoWindow = com.naver.maps.map.overlay.InfoWindow().apply {
            position = options.position.toNaver()
            alpha = options.alpha
            zIndex = options.zIndex
            anchor = PointF(options.anchor.first, options.anchor.second)
            offsetX = options.offsetX
            offsetY = options.offsetY
            adapter = object : com.naver.maps.map.overlay.InfoWindow.ViewAdapter() {
                override fun getView(infoWindow: com.naver.maps.map.overlay.InfoWindow): View {
                    return TextView(adapterContext).apply {
                        text = options.text
                        setTextColor(options.textColor)
                        setTextSize(TypedValue.COMPLEX_UNIT_SP, options.textSize)
                        val shape = GradientDrawable().apply {
                            setColor(options.backgroundColor)
                            cornerRadius = options.cornerRadiusDp.toFloat().dpToPx()
                        }
                        background = shape
                        val p = 8.toFloat().dpToPx().toInt()
                        setPadding(p, p, p, p)
                    }
                }
            }
            tag = options.tag
        }
        if (marker != null) nativeInfoWindow.open(marker.nativeMarker) else naverMap?.let { nativeInfoWindow.open(it) }
        return InfoWindow(nativeInfoWindow).also { _infoWindows.add(it) }
    }

    actual fun removeInfoWindow(infoWindow: InfoWindow) {
        infoWindow.close()
        _infoWindows.remove(infoWindow)
    }

    actual fun clearInfoWindows() {
        _infoWindows.forEach { it.close() }
        _infoWindows.clear()
    }

    actual fun clearAll() {
        clearMarkers()
        clearPolylines()
        clearPolygons()
        clearCircles()
        clearPaths()
        clearArrowheadPaths()
        clearInfoWindows()
    }

    actual fun animateCamera(position: CameraPosition, durationMs: Int, onFinish: (() -> Unit)?) {
        val update = CameraUpdate.toCameraPosition(position.toNaver()).animate(CameraAnimation.Easing, durationMs.toLong())
        naverMap?.moveCamera(update)
    }

    actual fun fitBounds(bounds: LatLngBounds, paddingDp: Int) {
        val paddingPx = paddingDp.toFloat().dpToPx().toInt()
        naverMap?.moveCamera(CameraUpdate.fitBounds(bounds.toNaver(), paddingPx))
    }
    actual fun setMapType(mapType: MapType) { naverMap?.mapType = mapType.toNaver() }
    actual fun setNightMode(enabled: Boolean) { naverMap?.isNightModeEnabled = enabled }
    actual fun setIndoorEnabled(enabled: Boolean) { naverMap?.isIndoorEnabled = enabled }
    actual fun setBuildingHeight(height: Float) { naverMap?.buildingHeight = height }
    actual fun setSymbolScale(scale: Float) { naverMap?.symbolScale = scale }
}
